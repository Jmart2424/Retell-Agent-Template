import fetch from 'node-fetch';
import OpenAI from "openai";
import { WebSocket } from "ws";
import {
  CustomLlmResponse,
  FunctionCall,
  ReminderRequiredRequest,
  ResponseRequiredRequest,
  Utterance,
} from "../types";

// PestAway Solutions - Samuel  LLM Client
// Generated by LLM Template Customizer with Knowledge Base ID Mapping
export class DemoLlmClient {
  private client: OpenAI;
  private contactSummary = "";
  
  // Enhanced Data Management System
  private sessionData: {
    contact?: any;
    knowledgeBase?: any[];
    calendarData?: any;
    customData?: { [key: string]: any };
  } = {};

  // KNOWLEDGE BASE ID MAPPING
  private knowledgeBaseMapping: { [key: string]: string } = {
    'Greenline Landscaping': 'knowledge_base_652ec0f35dbff57c',
    'Chop Details and Wraps': 'knowledge_base_649fac5906830726',
    'PestAway Solutions': 'knowledge_base_2a49b80dc103beb7',
    'CoolZone HVAC': 'knowledge_base_0101d490bcf05719',
    'United Financial': 'knowledge_base_32cbd40a19573cd2',
    'AFN': 'knowledge_base_5577315e5b38f822'
  };

  private getKnowledgeBaseId(): string | null {
    const companyName = 'PestAway Solutions';
    return this.knowledgeBaseMapping[companyName] || null;
  }

  constructor() {
    this.client = new OpenAI({
      apiKey: process.env.OPENAI_APIKEY,
      baseURL: "https://api.groq.com/openai/v1",
    });
  }

  // CUSTOM SYSTEM PROMPT FOR Samuel  AT PestAway Solutions
  private systemPrompt = `## Identity & Purpose
You are Samuel, a virtual assistant representing PestAway Solutions, a professional pest control provider based nationally in the US. Your purpose is to assist callers by answering service-related questions, confirming their needs, and helping them schedule an appointment or speak to a licensed technician. Your goal is to make the experience smooth, reassuring, and informative—especially for customers dealing with stressful pest situations.

## Voice & Persona

###Personality
- Sound professional, friendly, calm, and knowledgeable—like a helpful receptionist who’s been with the company for years.
- Show genuine concern for the caller’s pest issue, offering helpful guidance without sounding overly pushy.
- Project confidence and reassurance—make the customer feel like they’re in good hands.
- Avoid high-pressure sales language—focus on being informative and solution-oriented.

### Speech Characteristics
- Speak in a professional-friendly, happy tone. Think warm and inviting, not cartoonish.
- Use natural contractions (“you’re,” “we’ve,” “y’all” occasionally, if it fits contextually and naturally).
- Speak clearly, at a steady and calm pace, while sounding conversational and approachable.
- Vary phrasing and intonation slightly to avoid sounding robotic or repetitive.
- Use simple, accessible language when talking about pests, treatments, and pricing.
- Mirror the caller’s tone slightly—more upbeat if they are energetic, more measured if they sound cautious or unsure.
- Use gentle upward inflection at the end of welcoming or positive sentences to sound more engaging.
- Add slight emotional warmth to keywords like “home,” “help,” “family,” “relief,” or “support.”

## Response Guidelines
- Keep answers concise unless further clarification is helpful.
- Ask one question at a time to keep the flow natural.
- Vary confirmation and acknowledgment phrases to sound more natural and engaged. Use a rotating selection of responses like: “Got it”, “Okay”, “Okay, great”, "Understood", “Sounds good”, “Got it”, “I appreciate that”, “Great, thanks”
  - Avoid repeating the same phrase back-to-back in a single conversation.
  - Match tone to the context — more enthusiastic if the user is excited, more calm and neutral if the tone is serious.
- Avoid technical jargon unless the homeowner uses it first.
- Don’t overuse technical terms—keep explanations simple and benefit-driven.
- Always offer a clear next step (e.g., schedule a visit, connect with a tech).

## Scenario Handling
- If They Ask About our Company and/or what we do: Refer to PestAway Solutions knowledge base
- If They Interrupt: Respond directly to their response, then quickly get back on track.
- Avoid repeating their address after confirming.


## Conversational Flow
**Follow steps in order.  Don't transition to a different section unless explicitly given instructions to do so**
### Introduction
1. Greet Caller
- If {{first_name}} is not '[null]' say: "Thank you for calling PestAway Solutions! This is Samantha. Am I speaking with {{first_name}}?"
  - Wait for response
    - If they have not stated what they are calling about, ask: "How can I help you today?"
- If {{first_name}} is '[null]' say: "Thank you for calling PestAway Solutions! This is Samantha. How can I help you today?"
  - Wait for response
2. Determine if service is offered 
- If user asks or wants a service in knowledge base, move to step 3.
- If user asks or wants a service not listed in knowledge base, say: "We currently don't offer that at this time.  Is there something else I can help you with?"
  - If they say no, politely end call.
3. Say: "Ok great.  We can certainly handle that." 
4. Transition to different section based on intent
- If the caller mentions pests, problems, rodents, etc. - transition to 'Discovery Questions'.
- If the user mentions rescheduling an appointment -transition to 'Reschedule Appointment' under Scheduling Protocol.
- If the user mentions canceling an appointment - transition to 'Cancel Appointment' under Scheduling Protocol.

### Discovery Questions
- Purpose: Identify the pest issue, location, and urgency.
- Ask simple, one-at-a-time questions, using varied confirmation phrases after each.
1. Type of Problem
- If the user has not specified the pests or problem they have, ask: “What kind of pests are you seeing?”
- If the user has already specified the pests or problem, then move to step 2.
2. Service Recommendation
- Match the issue to a service from the PestAway Solutions knowledge base.
- Offer the best-fit service based on the issue.
- Highlight guarantees or benefits if applicable.
3. Confirm Service
- Ask: “Would you like to go ahead and schedule that service?”
  - If yes, transition to 'Schedule New Appointment'

## Scheduling Protocol
### Schedule New Appointment
**Ask one question at a time**
- When it is time to schedule an appointment:  **Follow the steps in order**
  - Current time is {{current_time}} Central Time (America/Chicago). Schedule only within the current calendar year and future dates.
  - Before booking the appointment, **always confirm with the user that you're checking availability.**
     - (e.g. “Let me double check availability for [suggested_time], just a moment…”)  
  1. Gather address
    - If \`street_address' is not '[null]', say: “To confirm, is {{street_address}} in {{city}} still your address?”  **speak the street number digit by digit**
      - If yes, pass '{{street_address}}, {{city}}, {{state}} {{zip_code}}' as address for the appointment
      - If no, or any value is [null], ask for 'street address, city, state, and zip code', then pass those values as the address for the appointment
        - If they tell you their address, repeat the address back to confirm.   Wait for confirmation.
  2. Say, "When are you looking to get this done?" 
    - Then check availability using check_avail_cal
      - If no times are returned, politely tell them we don't have anything available and ask if they want the next available.
      - If the slot is available, say, “I do have [suggested_time] available. Would you like me to schedule you for that time?”
        - **Wait for user confirmation before booking. Do not book until the user confirms.**
  3. Gather contact information
    - If 'first_name, last_name' is not '[null]': pass {{first_name}} {{last_name}} as the name for appointment
      - If any value is [null], ask: "Can I get your first and last name?"
    - If 'email' is not '[null]': pass {{email}} as the email for the appointment
      - If 'email' is [null], ask: "Can I get your email address?"
        - If they tell you their email, repeat email back to confirm.  Wait for confirmation.
    - Ask, "Is {{user_number}} a good contact number for you?"
      - If yes, pass {{user_number}} as phone for the appointment
      - If no, ask for a good contact number if they have not given one yet.
        - If they tell you their phone number, repeat phone number back to confirm.  Wait for confirmation.
    - Pass the type of service requested as serviceType for the appointment
    - Pass the make and model of vehicle as vehicle for the appointment
    - Pass the vehicle condition as vehicleCondition for the appointment
    - Pass the type of wrap the user wants as wrapType for the appointment
  4. Say: "Just a moment while I book the appointment".  
  5. Book appointment using book_appt function
  6. Confirm Appointment
    - Say: “The technician will call you when they are on the way.  If you need to reschedule, feel free to give me a call back."
  7. Ask: "Is there anything else I can help you with today?"
    - If they have any other questions or comments, handle accordingly.
    - If they say no, politely endCall.

### Reschedule Appointment
**Ask one question at a time**
- When they want to reschedule appointment:  **Follow the steps in order**
   - Current time is {{current_time}} Central Time (America/Chicago). Schedule only within the current calendar year and future dates.
  - Before booking the appointment, **always confirm with the user that you're checking availability**
  1. Use the cancel_appt function to cancel the original appointment
    - Pass {{email}} as attendeesEmail
  2. Confirm {{street_address}} is the property for the service. **speak the street number digit by digit**
      - If yes, pass '{{street_address}}, {{city}}, {{state}} {{zip_code}}' as address for the appointment
      - If no, ask for 'street address, city, state, and zip code', then pass those values as the address for the appointment
        - If they tell you their address, repeat the address back to confirm.  Wait for confirmation.
  3.  Ask, "Is there a particular day and time you are looking to schedule?" 
    - Then check availability using check_avail_cal
      - If no times are returned, politely tell them we don't have anything available and ask if they want the next available.
      - If the slot is available, say, “I do have [suggested_time] available. Would you like me to schedule you for that time?”
        - **Wait for user confirmation before booking. Do not book until the user confirms.**
  4. Say: "Just a moment while I book the appointment".
  5. Schedule using book_appt
    - Pass {{first_name}} {{last_name}} as the name for appointment
    - Pass {{email}} as the email for the appointment
    - Pass {{phone}} as the phone number for the appointment
    - Pass {{service_type}} as the service type for appointment
  6. Confirm appointment
    - Say: “The technician will call you when they are on the way.  If you need to reschedule, feel free to give me a call back."
  7. Ask: "Is there anything else I can help you with today?"
    - If they have any other questions or comments, handle accordingly.
    - If they say no, politely endCall.

### Cancel Appointment
- When they want to cancel an appointment:  **Follow the steps in order**
  1. Say: "Sure, is there any particular reason you are cancelling?"
  2. Use the cancel_appt function to cancel the appointment
    - Pass {{email}} as attendeesEmail 


IMPORTANT FUNCTION USAGE:
- When customer asks about the company, services, or business information, ALWAYS use the knowledge_search function first
- Examples that MUST trigger knowledge_search: "tell me about your company", "what do you do", "what services do you offer", "company information"
- Use the exact customer question as the query parameter`;

  // Data Management Methods
  private updateSessionData(functionName: string, data: any): void {
    switch (functionName) {
      case "ghl_lookup":
        this.sessionData.contact = data.contact || data;
        this.updateContactSummary();
        break;
      case "knowledge_search":
        if (!this.sessionData.knowledgeBase) this.sessionData.knowledgeBase = [];
        this.sessionData.knowledgeBase.push(data);
        break;
      case "check_avail_cal":
        this.sessionData.calendarData = data;
        break;
      default:
        if (!this.sessionData.customData) this.sessionData.customData = {};
        this.sessionData.customData[functionName] = data;
    }
  }

  private updateContactSummary(): void {
    const contact = this.sessionData.contact;
    if (contact) {
      let summary = `Contact: ${contact.firstName || ""} ${contact.lastName || ""}`;
      if (contact.email) summary += `, Email: ${contact.email}`;
      if (contact.phone) summary += `, Phone: ${contact.phone}`;
      if (contact.serviceHistory) summary += `, Service History: ${Array.isArray(contact.serviceHistory) ? contact.serviceHistory.join(", ") : contact.serviceHistory}`;
      this.contactSummary = summary;
    }
  }

  private getPersonalizedContext(): string {
    let context = "";
    if (this.sessionData.contact) {
      const c = this.sessionData.contact;
      context += `Customer: ${c.firstName || ""} ${c.lastName || ""}. `;
      if (c.serviceHistory) context += `Previous services: ${Array.isArray(c.serviceHistory) ? c.serviceHistory.join(", ") : c.serviceHistory}. `;
    }
    if (this.sessionData.knowledgeBase && this.sessionData.knowledgeBase.length > 0) {
      context += "Available knowledge: " + this.sessionData.knowledgeBase.map(kb => kb.summary || kb.title || "Information available").join(", ") + ". ";
    }
    return context;
  }

  // CUSTOM GREETING LOGIC FOR Samuel 
  BeginMessage(ws: WebSocket, contactJson: any = {}) {
    let contact: any = {};
    try {
      contact = contactJson.contact ?? contactJson.data ?? contactJson;
    } catch {
      contact = {};
    }

    const firstName = contact.firstName || contact.first_name || "";

    // Store initial contact data
    if (contact && Object.keys(contact).length > 0) {
      this.sessionData.contact = contact;
      this.updateContactSummary();
    }

    // Samuel  greeting for PestAway Solutions
    const greeting = `Hi, this is Samuel with PestAway Solutions. How can I help you today?`;

    const res: CustomLlmResponse = {
      response_type: "response",
      response_id: 0,
      content: greeting,
      content_complete: true,
      end_call: false,
    };
    ws.send(JSON.stringify(res));
  }

  // Function definitions for PestAway Solutions
  private functions: OpenAI.Chat.Completions.ChatCompletionTool[] = [
    {
      type: "function",
      function: {
        name: "check_avail_cal",
        description: "Check calendar availability for appointment through Cal.com for PestAway Solutions",
        parameters: {
          type: "object",
          properties: {
            start: { type: "string", description: "Start time range in ISO 8601 format" },
            end: { type: "string", description: "End time range in ISO 8601 format" }
          },
          required: ["start", "end"]
        }
      }
    },
    {
      type: "function",
      function: {
        name: "ghl_lookup",
        description: "Lookup contact information in PestAway Solutions database using GoHighLevel for personalization",
        parameters: {
          type: "object",
          properties: {
            phone: { type: "string", description: "Phone number to lookup" },
            email: { type: "string", description: "Email address to lookup" },
            name: { type: "string", description: "Customer name to lookup" }
          },
          required: ["phone"]
        }
      }
    },
    {
      type: "function",
      function: {
        name: "knowledge_search",
        description: "ALWAYS call this function when customer asks ANY question about the company, services, or business information. Trigger phrases include: 'tell me about your company', 'what does your company do', 'what services do you offer', 'company information', 'about your business', 'what do you do', 'your services', 'company details', or any question about PestAway Solutions. This function searches the PestAway Solutions knowledge base for accurate company information.",
        parameters: {
          type: "object",
          properties: {
            query: { 
              type: "string", 
              description: "The customer's exact question or what they want to know about the company" 
            },
            category: { 
              type: "string", 
              description: "Category: services, about, policies, contact, general",
              enum: ["services", "about", "policies", "contact", "general"]
            }
          },
          required: ["query"]
        }
      }
    },
    {
      type: "function",
      function: {
        name: "end_call",
        description: "End the call gracefully for PestAway Solutions",
        parameters: {
          type: "object",
          properties: {
            reason: { type: "string" }
          },
          required: ["reason"]
        }
      }
    }
  ];

  // WEBHOOK CONFIGURATION FOR PestAway Solutions with Knowledge Base ID Mapping
  private async handleFunctionCall(functionName: string, parameters: any): Promise<string> {
    const webhookEndpoints: { [key: string]: string | null } = {
      'check_avail_cal': null,
      'ghl_lookup': null,
      'knowledge_search': 'https://n8n-cloudhosted.onrender.com/webhook/knowledge-search',
      'end_call': null
    };

    if (functionName === 'end_call') {
      return JSON.stringify({
        success: true,
        message: parameters.reason || "Thank you for calling PestAway Solutions!"
      });
    }

    const webhookUrl = webhookEndpoints[functionName];
    if (!webhookUrl) {
      return JSON.stringify({ error: `No webhook configured for function: ${functionName}` });
    }

    try {
      // Enhanced request body with session context and knowledge base ID
      let requestBody: any = {};
      
      if (functionName === 'check_avail_cal') {
        requestBody = {
          args: {
            start: parameters.start,
            end: parameters.end
          },
          function_name: functionName,
          company: 'PestAway Solutions',
          assistant: 'Samuel ',
          session_context: this.sessionData,
          timestamp: new Date().toISOString()
        };
      } else {
        requestBody = {
          function_name: functionName,
          parameters: parameters,
          company: 'PestAway Solutions',
          assistant: 'Samuel ',
          session_context: this.sessionData,
          timestamp: new Date().toISOString()
        };

        // Add knowledge base ID for knowledge_search function
        if (functionName === 'knowledge_search') {
          const knowledgeBaseId = this.getKnowledgeBaseId();
          if (knowledgeBaseId) {
            requestBody.knowledge_base_id = knowledgeBaseId;
            requestBody.parameters = {
              ...requestBody.parameters,
              knowledge_base_id: knowledgeBaseId
            };
          }
        }
      }

      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'PestAway Solutions-Samuel -LLM-Client'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      this.updateSessionData(functionName, result);
      return JSON.stringify(result);
    } catch (error) {
      console.error(`Error calling ${functionName} for PestAway Solutions:`, error);
      return JSON.stringify({
        error: `Failed to execute ${functionName}`,
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // ESSENTIAL METHODS - Required by server.ts
  private ConversationToChatRequestMessages(conversation: Utterance[]) {
    const result: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [];
    for (const turn of conversation) {
      result.push({
        role: turn.role === "agent" ? "assistant" : "user",
        content: turn.content,
      });
    }
    return result;
  }

  private PreparePrompt(
    request: ResponseRequiredRequest | ReminderRequiredRequest,
    funcResult?: FunctionCall,
  ) {
    const transcript = this.ConversationToChatRequestMessages(request.transcript);
    const requestMessages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
      {
        role: "system",
        content: this.systemPrompt,
      },
    ];

    // Add personalized context
    const personalizedContext = this.getPersonalizedContext();
    if (personalizedContext) {
      requestMessages.push({
        role: "system",
        content: `Session Context: ${personalizedContext}`,
      });
    }

    if (this.contactSummary && this.contactSummary.trim()) {
      requestMessages.push({
        role: "assistant",
        content: this.contactSummary,
      });
    }

    for (const message of transcript) {
      requestMessages.push(message);
    }

    if (funcResult) {
      requestMessages.push({
        role: "assistant",
        content: null,
        tool_calls: [
          {
            id: funcResult.id,
            type: "function",
            function: {
              name: funcResult.funcName,
              arguments: JSON.stringify(funcResult.arguments),
            },
          },
        ],
      });
      requestMessages.push({
        role: "tool",
        tool_call_id: funcResult.id,
        content: funcResult.result || "",
      });
    }

    if (request.interaction_type === "reminder_required") {
      requestMessages.push({
        role: "user",
        content: "(Now the user has not responded in a while, you would say:)",
      });
    }

    return requestMessages;
  }

  // MAIN DRAFT RESPONSE METHOD - Required by server.ts
  async DraftResponse(
    request: ResponseRequiredRequest | ReminderRequiredRequest,
    ws: WebSocket,
    funcResult?: FunctionCall,
  ) {
    console.clear();
    console.log("req", request);

    if (request.interaction_type !== "response_required" && request.interaction_type !== "reminder_required") {
      return;
    }

    const requestMessages = this.PreparePrompt(request, funcResult);

    let funcCall: FunctionCall | undefined;
    let funcArguments = "";
    let toolCallHandled = false;

    try {
      const events = await this.client.chat.completions.create({
        model: "llama-3.1-8b-instant",
        messages: requestMessages,
        stream: true,
        temperature: 0.1,
        max_tokens: 200,
        frequency_penalty: 1.0,
        presence_penalty: 1.0,
        tools: this.functions,
      });

      for await (const event of events) {
        if (event.choices && event.choices.length >= 1) {
          const delta = event.choices[0].delta;
          if (!delta) continue;

          if (delta.tool_calls && delta.tool_calls.length > 0 && !toolCallHandled) {
            const toolCall = delta.tool_calls[0];
            if (toolCall.id && toolCall.function?.name) {
              funcArguments += toolCall.function.arguments || "";
              funcCall = {
                id: toolCall.id,
                funcName: toolCall.function.name,
                arguments: {},
              };
              continue;
            }
          } else if (funcCall && funcArguments && !toolCallHandled) {
            funcCall.arguments = JSON.parse(funcArguments);
            const functionResult = await this.handleFunctionCall(funcCall.funcName, funcCall.arguments);

            let parsedResult: any;
            try {
              parsedResult = JSON.parse(functionResult);
            } catch {
              parsedResult = { error: "Invalid response format" };
            }

            let responseContent = "";
            const customerName = this.sessionData.contact?.firstName || "";
            const personalPrefix = customerName ? `${customerName}, ` : "";
            
            if (funcCall.funcName === "ghl_lookup" && parsedResult.success) {
              responseContent = `${personalPrefix}I found your information in our system. ${parsedResult.message || "How can I help you today?"}`;
            } else if (funcCall.funcName === "knowledge_search" && parsedResult.results) {
              responseContent = `${personalPrefix}I found some information that might help: ${parsedResult.summary || parsedResult.results[0]?.content || "Information available."}`;
            } else if (parsedResult.available) {
              responseContent = `${personalPrefix}Great! ${parsedResult.message || 'That time slot is available.'}`;
              if (parsedResult.suggested_times && Array.isArray(parsedResult.suggested_times) && parsedResult.suggested_times.length > 0) {
                responseContent += ` I also have these alternative times available: ${parsedResult.suggested_times.join(", ")}.`;
              }
            } else if (parsedResult.success) {
              responseContent = `${personalPrefix}${parsedResult.message || "I've processed your request successfully."}`;
            } else {
              responseContent = `${personalPrefix}I'm sorry, that time slot isn't available. Let me suggest some alternatives.`;
              if (parsedResult.suggested_times && Array.isArray(parsedResult.suggested_times) && parsedResult.suggested_times.length > 0) {
                responseContent += ` How about: ${parsedResult.suggested_times.join(", ")}?`;
              }
            }

            const res: CustomLlmResponse = {
              response_type: "response",
              response_id: request.response_id,
              content: responseContent,
              content_complete: true,
              end_call: false,
            };
            ws.send(JSON.stringify(res));
            toolCallHandled = true;
            break;
          } else if (delta.content && !toolCallHandled) {
            const res: CustomLlmResponse = {
              response_type: "response",
              response_id: request.response_id,
              content: delta.content,
              content_complete: false,
              end_call: false,
            };
            ws.send(JSON.stringify(res));
          }
        }
      }
    } catch (err) {
      console.error("Error in gpt stream: ", err);
    } finally {
      if (funcCall && funcCall.funcName === "end_call") {
        const customerName = this.sessionData.contact?.firstName || "";
        const personalizedGoodbye = customerName ? `Thank you ${customerName} for calling PestAway Solutions!` : "Thank you for calling PestAway Solutions!";
        const res: CustomLlmResponse = {
          response_type: "response",
          response_id: request.response_id,
          content: personalizedGoodbye,
          content_complete: true,
          end_call: true,
        };
        ws.send(JSON.stringify(res));
      }
    }
  }
}
