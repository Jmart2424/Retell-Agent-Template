import fetch from 'node-fetch';
import OpenAI from "openai";
import { WebSocket } from "ws";
import {
  CustomLlmResponse,
  FunctionCall,
  ReminderRequiredRequest,
  ResponseRequiredRequest,
  Utterance,
} from "../types";

// CoolZone HVAC - Wanda LLM Client
// Generated by LLM Template Customizer with Cal.com Integration
export class DemoLlmClient {
  private client: OpenAI;
  private contactSummary = "";

  // Custom field mapping - UPDATE FOR YOUR PROJECT
  private customFieldMapping: { [key: string]: string } = {
    "SeLYuAVIdqR3xz31DgX5": "Home Value",
    "K2oQYXcF7zmZgbNZJgaz": "Loan Amount",
    // Add your custom field mappings here for CoolZone HVAC
  };

  constructor() {
    this.client = new OpenAI({
      apiKey: process.env.OPENAI_APIKEY,
      baseURL: "https://api.groq.com/openai/v1",
    });
  }

  // CUSTOM SYSTEM PROMPT FOR Wanda AT CoolZone HVAC
  private systemPrompt = `## Identity & Purpose
You are Sarah, a virtual assistant representing TechSupport Pro, a trusted technology support service provider. Your purpose is to assist callers with their technical issues by gathering key information, diagnosing problems, and scheduling support appointments when needed.

## Voice & Persona
- Sound professional, friendly, and knowledgeable about technology
- Show patience and understanding for technical difficulties
- Use simple, non-technical language unless the caller demonstrates technical knowledge
- Project confidence in your ability to help solve their problems

## Response Guidelines
- Keep explanations simple and step-by-step
- Ask one question at a time to avoid overwhelming the caller
- Always confirm understanding before moving to the next step
- Offer clear next steps for resolution

## Conversational Flow
1. Greet the caller and identify their technical issue
2. Gather device and problem details
3. Attempt basic troubleshooting if appropriate
4. Schedule technician visit if needed
5. Confirm appointment details and provide ticket number`;

  // CUSTOM GREETING LOGIC FOR Wanda
  BeginMessage(ws: WebSocket, contactJson: any = {}) {
    let contact: any = {};
    try {
      contact = contactJson.contact ?? contactJson.data ?? contactJson;
    } catch {
      contact = {};
    }

    const firstName = contact.firstName || contact.first_name || "";

    // Wanda greeting for CoolZone HVAC
    const greeting = `Hi this is Wanda with CooZone HVAC, Am I speaking with ${firstName}?`;

    const res: CustomLlmResponse = {
      response_type: "response",
      response_id: 0,
      content: greeting,
      content_complete: true,
      end_call: false,
    };
    ws.send(JSON.stringify(res));
  }

  // Function definitions for CoolZone HVAC with Cal.com Integration
  private functions: OpenAI.Chat.Completions.ChatCompletionTool[] = [
    {
      type: "function",
      function: {
        name: "check_avail_cal",
        description: "Check calendar availability for appointment through Cal.com for CoolZone HVAC",
        parameters: {
  "type": "object",
  "properties": {
    "start": {
      "type": "string",
      "description": "Start time range in ISO 8601 format"
    },
    "end": {
      "type": "string",
      "description": "End time range in ISO 8601 format"
    }
  },
  "required": [
    "start",
    "end"
  ]
}
      }
    },
    {
      type: "function",
      function: {
        name: "ghl_lookup",
        description: "Lookup contact information in CoolZone HVAC database using GoHighLevel",
        parameters: {
          type: "object",
          properties: {
            phone: { type: "string" },
            email: { type: "string" }
          },
          required: ["phone"]
        }
      }
    },
    {
      type: "function",
      function: {
        name: "end_call",
        description: "End the call gracefully for CoolZone HVAC",
        parameters: {
          type: "object",
          properties: {
            reason: { type: "string" }
          },
          required: ["reason"]
        }
      }
    }
  ];

  // WEBHOOK CONFIGURATION FOR CoolZone HVAC with Cal.com Integration
  private async handleFunctionCall(functionName: string, parameters: any): Promise<string> {
    const webhookEndpoints: { [key: string]: string | null } = {
      'check_avail_cal': null,
      'ghl_lookup': null,
      'end_call': null
    };

    if (functionName === 'end_call') {
      return JSON.stringify({
        success: true,
        message: parameters.reason || "Thank you for calling CoolZone HVAC!"
      });
    }

    const webhookUrl = webhookEndpoints[functionName];
    if (!webhookUrl) {
      return JSON.stringify({ error: `No webhook configured for function: ${functionName}` });
    }

    try {
      // Special handling for Cal.com check_avail_cal function
      let requestBody;
      if (functionName === 'check_avail_cal') {
        requestBody = {
          args: {
            start: parameters.start,
            end: parameters.end
          },
          function_name: functionName,
          company: 'CoolZone HVAC',
          assistant: 'Wanda',
          timestamp: new Date().toISOString()
        };
      } else {
        requestBody = {
          function_name: functionName,
          parameters: parameters,
          company: 'CoolZone HVAC',
          assistant: 'Wanda',
          timestamp: new Date().toISOString()
        };
      }

      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'CoolZone HVAC-Wanda-LLM-Client'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      return JSON.stringify(result);
    } catch (error) {
      console.error(`Error calling ${functionName} for CoolZone HVAC:`, error);
      return JSON.stringify({
        error: `Failed to execute ${functionName}`,
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // ESSENTIAL METHODS - Required by server.ts
  private ConversationToChatRequestMessages(conversation: Utterance[]) {
    const result: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [];
    for (const turn of conversation) {
      result.push({
        role: turn.role === "agent" ? "assistant" : "user",
        content: turn.content,
      });
    }
    return result;
  }

  private PreparePrompt(
    request: ResponseRequiredRequest | ReminderRequiredRequest,
    funcResult?: FunctionCall,
  ) {
    const transcript = this.ConversationToChatRequestMessages(request.transcript);
    const requestMessages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
      {
        role: "system",
        content: this.systemPrompt,
      },
    ];

    if (this.contactSummary && this.contactSummary.trim()) {
      requestMessages.push({
        role: "assistant",
        content: this.contactSummary,
      });
    }

    for (const message of transcript) {
      requestMessages.push(message);
    }

    if (funcResult) {
      requestMessages.push({
        role: "assistant",
        content: null,
        tool_calls: [
          {
            id: funcResult.id,
            type: "function",
            function: {
              name: funcResult.funcName,
              arguments: JSON.stringify(funcResult.arguments),
            },
          },
        ],
      });
      requestMessages.push({
        role: "tool",
        tool_call_id: funcResult.id,
        content: funcResult.result || "",
      });
    }

    if (request.interaction_type === "reminder_required") {
      requestMessages.push({
        role: "user",
        content: "(Now the user has not responded in a while, you would say:)",
      });
    }

    return requestMessages;
  }

  // MAIN DRAFT RESPONSE METHOD - Required by server.ts
  async DraftResponse(
    request: ResponseRequiredRequest | ReminderRequiredRequest,
    ws: WebSocket,
    funcResult?: FunctionCall,
  ) {
    console.clear();
    console.log("req", request);

    if (request.interaction_type !== "response_required" && request.interaction_type !== "reminder_required") {
      return;
    }

    const requestMessages = this.PreparePrompt(request, funcResult);

    let funcCall: FunctionCall | undefined;
    let funcArguments = "";
    let toolCallHandled = false;

    try {
      const events = await this.client.chat.completions.create({
        model: "llama-3.1-8b-instant",
        messages: requestMessages,
        stream: true,
        temperature: 0.1,
        max_tokens: 200,
        frequency_penalty: 1.0,
        presence_penalty: 1.0,
        tools: this.functions,
      });

      for await (const event of events) {
        if (event.choices && event.choices.length >= 1) {
          const delta = event.choices[0].delta;
          if (!delta) continue;

          if (delta.tool_calls && delta.tool_calls.length > 0 && !toolCallHandled) {
            const toolCall = delta.tool_calls[0];
            if (toolCall.id && toolCall.function?.name) {
              funcArguments += toolCall.function.arguments || "";
              funcCall = {
                id: toolCall.id,
                funcName: toolCall.function.name,
                arguments: {},
              };
              continue;
            }
          } else if (funcCall && funcArguments && !toolCallHandled) {
            funcCall.arguments = JSON.parse(funcArguments);
            const functionResult = await this.handleFunctionCall(funcCall.funcName, funcCall.arguments);

            let parsedResult: any;
            try {
              parsedResult = JSON.parse(functionResult);
            } catch {
              parsedResult = { error: "Invalid response format" };
            }

            let responseContent = "";
            if (parsedResult.available) {
              responseContent = `Great! ${parsedResult.message || 'That time slot is available.'}`;
              if (parsedResult.suggested_times && Array.isArray(parsedResult.suggested_times) && parsedResult.suggested_times.length > 0) {
                responseContent += ` I also have these alternative times available: ${parsedResult.suggested_times.join(", ")}.`;
              }
            } else if (parsedResult.success && funcCall.funcName === "ghl_lookup") {
              responseContent = parsedResult.message || "Contact information found.";
            } else {
              responseContent = `I'm sorry, that time slot isn't available. Let me suggest some alternatives.`;
              if (parsedResult.suggested_times && Array.isArray(parsedResult.suggested_times) && parsedResult.suggested_times.length > 0) {
                responseContent += ` How about: ${parsedResult.suggested_times.join(", ")}?`;
              }
            }

            const res: CustomLlmResponse = {
              response_type: "response",
              response_id: request.response_id,
              content: responseContent,
              content_complete: true,
              end_call: false,
            };
            ws.send(JSON.stringify(res));
            toolCallHandled = true;
            break;
          } else if (delta.content && !toolCallHandled) {
            const res: CustomLlmResponse = {
              response_type: "response",
              response_id: request.response_id,
              content: delta.content,
              content_complete: false,
              end_call: false,
            };
            ws.send(JSON.stringify(res));
          }
        }
      }
    } catch (err) {
      console.error("Error in gpt stream: ", err);
    } finally {
      if (funcCall && funcCall.funcName === "end_call") {
        const res: CustomLlmResponse = {
          response_type: "response",
          response_id: request.response_id,
          content: "Thank you for calling CoolZone HVAC!",
          content_complete: true,
          end_call: true,
        };
        ws.send(JSON.stringify(res));
      }
    }
  }
}
